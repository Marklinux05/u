<!-- Flower Shader ‚Äî Loto Fixed (cleaned) -->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flower Shader ‚Äî Loto Fixed</title>
  <style>
    :root{--card-w:380px;--card-h:500px}
    html,body{height:100%;margin:0;padding:0;background:#08111a;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    /* center card */
    .card{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#07101a99,#071827aa);z-index:9999}
    .card-content{position:relative;overflow:hidden;background:radial-gradient(circle at 30% 20%, rgba(255,255,255,0.04), rgba(255,255,255,0.01));border-radius:16px;padding:28px 34px;text-align:center;color:#fff;backdrop-filter:blur(6px);box-shadow:0 10px 40px rgba(0,0,0,0.6);min-width:320px}
    .card-content h1{margin:0;font-size:36px;letter-spacing:1px}
    .card-content .subtitle{margin:8px 0 18px;color:#dbeafe}
    .card-content button{background:#ffd6e0;border:none;padding:10px 18px;border-radius:10px;font-weight:600;cursor:pointer;transition:transform .18s ease,box-shadow .18s ease}
    .card-content button:hover{transform:translateY(-4px);box-shadow:0 12px 28px rgba(0,0,0,.35)}

    /* lotto card (small) */
    #lottoCard{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:var(--card-w);height:var(--card-h);border-radius:14px;overflow:hidden;background:#c9a449;box-shadow:0 20px 60px rgba(0,0,0,.6);z-index:100001;display:none}
    #lottoCard .frame{position:relative;width:100%;height:100%}
    #lottoCard img{width:100%;height:100%;object-fit:cover;display:block;filter:brightness(.98) saturate(1.05);transition:opacity 1.5s ease}
    #lottoOverlay{pointer-events:auto}

    /* main webgl canvas and container */
    .container{position:fixed;inset:0;display:flex;flex-direction:column-reverse;align-items:flex-start}
    #canvas{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1}
    .clean-btn{z-index:3;font-family:sans-serif;font-size:15px;color:white;text-shadow:0 0 10px #000;user-select:none;padding:0 0 15px 25px;cursor:pointer;text-decoration:underline;opacity:.7}

    /* animated name */
    .name{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;text-align:center;font-size:4vw;text-shadow:0 0 5px #000;user-select:none;pointer-events:none;opacity:0;animation:fadeInText 2s ease forwards}
    @keyframes fadeInText{0%{opacity:0;transform:translate(-50%,-50%) scale(.85);}70%{opacity:1;transform:translate(-50%,-50%) scale(1.05);}100%{opacity:1;transform:translate(-50%,-50%) scale(1)}}
    .name.hideText{animation:fadeOutText 1s ease forwards}
    @keyframes fadeOutText{to{opacity:0;transform:translate(-50%,-50%) scale(.9)}}

    /* hearts */
    .heart{position:fixed;width:18px;height:18px;pointer-events:none;font-size:18px;transform:translate(-50%,-50%)}

    /* responsive tweaks */
    @media (min-width:640px){.card-content h1{font-size:44px}.name{font-size:45px}}
  .gift-btn{
  margin-top:14px;
  width:100%;
  padding:12px 20px;
  border:none;
  border-radius:22px;
  font-size:17px;
  font-weight:600;
  font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  color:#000; /* changed to black text */
  background: linear-gradient(135deg, #ffd6e0, #ffced9); /* lighter iOS-like gradient */
  box-shadow: 0 6px 18px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.6);
  cursor:pointer;
  transition: all .18s ease;
  letter-spacing:0.3px;
}
.gift-btn:hover{
  transform:translateY(-3px) scale(1.03);
  background: linear-gradient(135deg, #5a5a5a, #2a2a2a);
  box-shadow:0 8px 20px rgba(0,0,0,0.45), inset 0 1px 1px rgba(255,255,255,0.1);
}
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:100050}
.modal-content{background:transparent;border-radius:14px;padding:20px;max-width:420px;width:92%;}
.scratch-card-modal{background:linear-gradient(180deg,#c9a449,#b68f30);border-radius:16px;padding:14px;box-shadow:0 18px 60px rgba(0,0,0,.6);display:flex;flex-direction:column;align-items:center}
.scratch-card-modal .card-inner{position:relative;width:360px;height:460px;border-radius:14px;overflow:hidden}
.scratch-card-modal img{width:100%;height:100%;object-fit:cover;display:block}
.scratch-card-modal canvas{position:absolute;inset:0;width:100%;height:100%;border-radius:14px;cursor:pointer}
.modal-controls{display:flex;gap:10px;margin-top:12px}
.modal-controls button{padding:8px 12px;border-radius:10px;border:none;cursor:pointer}
.show-image-btn{background:#fff;color:#000;font-weight:700}
.reset-btn{background:#000;color:#fff}
.close-modal{position:absolute;right:12px;top:8px;background:transparent;border:0;color:#fff;font-size:20px;cursor:pointer}
</style>
</head>
<body>
  <!-- Intro card -->
  <div class="card" id="card">
    <div class="card-content">
      <h1>‚ù§Ô∏è–†–∞—Ö–∏–º–∞—Ö–æ–Ω‚ù§Ô∏è</h1>
      <p class="subtitle">–¢—ã ‚Äî –º–æ—è –ª—É–Ω–∞, –æ—Å–≤–µ—â–∞—é—â–∞—è –º–æ—é –∂–∏–∑–Ω—å. –Ø –æ—á–µ–Ω—å —Å–∏–ª—å–Ω–æ —Ç–µ–±—è –ª—é–±–ª—é.</p>
      <button id="openCardBtn">–û—Ç–∫—Ä—ã—Ç—å</button>
      <button id="giftBtn" class="gift-btn">–ü–æ–¥–∞—Ä–æ–∫ üéÅ</button>
      
    </div>
  </div>

  <!-- Lotto card modal (scratch) -->
  <div class="modal-overlay" id="giftModal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true">
      <div class="scratch-card-modal">
        <button class="close-modal" id="giftCloseModal">‚úï</button>
        <div class="card-inner">
          <img src="photo_2025-12-01_01-39-50.jpg" id="giftImage" alt="gift image">
          <canvas id="scratchCanvas" width="360" height="460"></canvas>
        </div>
        <div class="modal-controls">
          <button class="show-image-btn" id="revealBtn">–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É</button>
          <button class="reset-btn" id="resetScratch">–°—Ç–µ—Ä–µ—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        </div>
      </div>
    </div>
  </div>
  </div>
  <!-- WebGL flower canvas and controls -->
  <div class="container">
    <canvas id="canvas"></canvas>
    <div class="clean-btn">—ç—Ç–æ –¥–ª—è –º–æ—é –ª—É–Ω—Éüåô</div>
  </div>

  <div class="name" id="animatedName">‚ù§Ô∏è–†–∞—Ö–∏–º–∞—Ö–æ–Ω‚ù§Ô∏è</div>

  <!-- Shaders (unchanged) -->
  <script type="x-shader/x-fragment" id="fragmentShader">#define PI 3.14159265359

uniform float u_ratio;
uniform vec2 u_cursor;
uniform float u_stop_time;
uniform float u_clean;
uniform vec2 u_stop_randomizer;

uniform sampler2D u_texture;
varying vec2 vUv;

vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
    m = m*m;
    m = m*m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    vec3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

float get_flower_shape(vec2 _p, float _pet_n, float _angle, float _outline) {
    _angle *= 3.;
    _p = vec2(_p.x * cos(_angle) - _p.y * sin(_angle), _p.x * sin(_angle) + _p.y * cos(_angle));
    float a = atan(_p.y, _p.x);
    float flower_sectoral_shape = pow(abs(sin(a * _pet_n)), .4) + .25;
    vec2 flower_size_range = vec2(.03, .1);
    float size = flower_size_range[0] + u_stop_randomizer[0] * flower_size_range[1];
    float flower_radial_shape = pow(length(_p) / size, 2.);
    flower_radial_shape -= .1 * sin(8. * a);
    flower_radial_shape = max(.1, flower_radial_shape);
    flower_radial_shape += smoothstep(0., 0.03, -_p.y + .2 * abs(_p.x));
    float grow_time = step(.25, u_stop_time) * pow(u_stop_time, .3);
    float flower_shape = 1. - smoothstep(0., flower_sectoral_shape, _outline * flower_radial_shape / grow_time);
    flower_shape *= (1. - step(1., grow_time));
    return flower_shape;
}

float get_stem_shape(vec2 _p, vec2 _uv, float _w, float _angle) {
    _w = max(.004, _w);
    float x_offset = _p.y * sin(_angle);
    x_offset *= pow(3. * _uv.y, 2.);
    _p.x -= x_offset;
    float noise_power = .5;
    float cursor_horizontal_noise = noise_power * snoise(2. * _uv * u_stop_randomizer[0]);
    cursor_horizontal_noise *= pow(dot(_p.y, _p.y), .6);
    cursor_horizontal_noise *= pow(dot(_uv.y, _uv.y), .3);
    _p.x += cursor_horizontal_noise;
    float left = smoothstep(-_w, 0., _p.x);
    float right = 1. - smoothstep(0., _w, _p.x);
    float stem_shape = left * right;
    float grow_time = 1. - smoothstep(0., .2, u_stop_time);
    float stem_top_mask = smoothstep(0., pow(grow_time, .5), .03 -_p.y);
    stem_shape *= stem_top_mask;
    stem_shape *= (1. - step(.17, u_stop_time));
    return stem_shape;
}

void main() {
    vec3 base = texture2D(u_texture, vUv).xyz;
    vec2 uv = vUv;
    uv.x *= u_ratio;
    vec2 cursor = vUv - u_cursor.xy;
    cursor.x *= u_ratio;
    vec3 stem_color = vec3(.1 + u_stop_randomizer[0] * .6, .6, .2);
    vec3 flower_color = vec3(.6 + .5 * u_stop_randomizer[1], .1, .9 - .5 * u_stop_randomizer[1]);
    float angle = .5 * (u_stop_randomizer[0] - .5);
    float stem_shape = get_stem_shape(cursor, uv, .003, angle);
    stem_shape += get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .003, angle);
    float stem_mask = 1. - get_stem_shape(cursor, uv, .004, angle);
    stem_mask -= get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .004, angle);
    float petals_back_number = 1. + floor(u_stop_randomizer[0] * 2.);
    float angle_offset = -(2. * step(0., angle) - 1.) * .1 * u_stop_time;
    float flower_back_shape = get_flower_shape(cursor, petals_back_number, angle + angle_offset, 1.5);
    float flower_back_mask = 1. - get_flower_shape(cursor, petals_back_number, angle + angle_offset, 1.6);
    float petals_front_number = 2. + floor(u_stop_randomizer[1] * 2.);
    float flower_front_shape = get_flower_shape(cursor, petals_front_number, angle, 1.);
    float flower_front_mask = 1. - get_flower_shape(cursor, petals_front_number, angle, .95);
    vec3 color = base;
    color *= stem_mask;
    color *= flower_back_mask;
    color *= flower_front_mask;
    color += (stem_shape * stem_color);
    color += (flower_back_shape * (flower_color + vec3(0., .8 * u_stop_time, 0.)));
    color += (flower_front_shape * flower_color);
    color.r *= 1. - (.5 * flower_back_shape * flower_front_shape);
    color.b *= 1. - (flower_back_shape * flower_front_shape);
    color *= u_clean;
    gl_FragColor = vec4(color, 1.);
}
</script>

<script type="x-shader/x-vertex" id="vertexShader">varying vec2 vUv;void main(){ vUv = uv; gl_Position = vec4(position,1.); }</script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.133.1/build/three.module'

// wrap initialization in DOMContentLoaded to ensure all elements exist
window.addEventListener('DOMContentLoaded', ()=>{
  const canvasEl = document.querySelector('#canvas');
  const cleanBtn = document.querySelector('.clean-btn');
  const pointer = { x:0.66, y:0.3, clicked:false };
  let cardOpen = true;
  let isTouchScreen = false;

  // three.js setup
  const renderer = new THREE.WebGLRenderer({ canvas: canvasEl, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  const sceneShader = new THREE.Scene();
  const sceneBasic = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,10);
  const clock = new THREE.Clock();

  let basicMaterial, shaderMaterial;
  let renderTargets = [ new THREE.WebGLRenderTarget(innerWidth, innerHeight), new THREE.WebGLRenderTarget(innerWidth, innerHeight) ];

  function createPlane(){
    shaderMaterial = new THREE.ShaderMaterial({
      uniforms: {
        u_stop_time: { value: 0 },
        u_stop_randomizer: { value: new THREE.Vector2(Math.random(), Math.random()) },
        u_cursor: { value: new THREE.Vector2(pointer.x, pointer.y) },
        u_ratio: { value: innerWidth/innerHeight },
        u_texture: { value: null },
        u_clean: { value: 1 }
      },
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent
    });

    basicMaterial = new THREE.MeshBasicMaterial();
    const geom = new THREE.PlaneGeometry(2,2);
    const planeBasic = new THREE.Mesh(geom, basicMaterial);
    const planeShader = new THREE.Mesh(geom, shaderMaterial);
    sceneBasic.add(planeBasic);
    sceneShader.add(planeShader);
  }

  function updateSize(){
    if(!shaderMaterial) return;
    shaderMaterial.uniforms.u_ratio.value = innerWidth/innerHeight;
    renderer.setSize(innerWidth, innerHeight);
    renderTargets[0].setSize(innerWidth, innerHeight);
    renderTargets[1].setSize(innerWidth, innerHeight);
  }

  function cleanCanvas(){ pointer.vanishCanvas = true; setTimeout(()=>pointer.vanishCanvas = false, 50); }

  function renderLoop(){
    if(!shaderMaterial) return;
    shaderMaterial.uniforms.u_clean.value = pointer.vanishCanvas ? 0 : 1;
    shaderMaterial.uniforms.u_texture.value = renderTargets[0].texture;

    if(pointer.clicked){
      shaderMaterial.uniforms.u_cursor.value = new THREE.Vector2(pointer.x, 1 - pointer.y);
      shaderMaterial.uniforms.u_stop_randomizer.value = new THREE.Vector2(Math.random(), Math.random());
      shaderMaterial.uniforms.u_stop_time.value = 0;
      pointer.clicked = false;
    }

    shaderMaterial.uniforms.u_stop_time.value += clock.getDelta();

    renderer.setRenderTarget(renderTargets[1]);
    renderer.render(sceneShader, camera);

    basicMaterial.map = renderTargets[1].texture;
    renderer.setRenderTarget(null);
    renderer.render(sceneBasic, camera);

    const tmp = renderTargets[0]; renderTargets[0] = renderTargets[1]; renderTargets[1] = tmp;
    requestAnimationFrame(renderLoop);
  }

  // hearts
  function spawnHearts(count){
    const rect = openCardBtn.getBoundingClientRect();
    const centerX = rect.left + rect.width/2;
    const centerY = rect.top + rect.height/2;
    for(let i=0;i<count;i++){
      const h = document.createElement('div');
      h.className='heart';
      h.style.left=centerX+'px'; h.style.top=centerY+'px';
      h.innerHTML = '‚ù§Ô∏è'; document.body.appendChild(h);
      void h.offsetWidth;
      const tx = (Math.random()-0.5)*140; const ty = - (80 + Math.random()*150);
      const scale = 0.6 + Math.random()*0.7; const rot = (Math.random()-0.5)*40;
      h.style.transition='transform 1.2s ease, opacity 1.2s ease';
      requestAnimationFrame(()=>{ h.style.transform = `translate(${tx}px, ${ty}px) scale(${scale}) rotate(${rot}deg)`; h.style.opacity='0'; });
      setTimeout(()=>{ try{ h.remove(); }catch(e){} },1500);
    }
  }

  // gift button ‚Üí open modal scratch
const giftBtnEl = document.getElementById('giftBtn');
const giftModal = document.getElementById('giftModal');
const giftCloseModal = document.getElementById('giftCloseModal');
const revealBtn = document.getElementById('revealBtn');
const resetScratch = document.getElementById('resetScratch');
let scratchState = { inited:false };

function initScratch(){
  const canvas = document.getElementById('scratchCanvas');
  const img = document.getElementById('giftImage');
  if(!canvas || !img) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  // draw golden overlay
  function fillGold(){ ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = '#b59445'; ctx.fillRect(0,0,w,h); }
  fillGold();
  let drawing=false;
  function getPos(e){ const r = canvas.getBoundingClientRect(); const clientX = (e.touches ? e.touches[0].clientX : e.clientX); const clientY = (e.touches ? e.touches[0].clientY : e.clientY); return {x: clientX - r.left, y: clientY - r.top}; }
  function draw(e){ if(!drawing) return; const p = getPos(e); ctx.globalCompositeOperation = 'destination-out'; ctx.beginPath(); ctx.arc(p.x, p.y, 28, 0, Math.PI*2); ctx.fill(); }
  canvas.addEventListener('mousedown', ()=> drawing=true);
  window.addEventListener('mouseup', ()=> drawing=false);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('touchstart', ()=> drawing=true, {passive:true});
  canvas.addEventListener('touchend', ()=> drawing=false);
  canvas.addEventListener('touchmove', draw, {passive:true});

  // percent cleared checker
  function getClearedPercent(){ const data = ctx.getImageData(0,0,w,h).data; let clear=0; for(let i=3;i<data.length;i+=4){ if(data[i]===0) clear++; } return clear / (w*h); }
  const checkInterval = setInterval(()=>{ if(getClearedPercent() > 0.35){ // reveal after 35%
      ctx.clearRect(0,0,w,h); clearInterval(checkInterval); revealBtn.style.display='inline-block'; }
  },400);

  revealBtn.onclick = ()=>{ ctx.clearRect(0,0,w,h); };
  resetScratch.onclick = ()=>{ fillGold(); revealBtn.style.display='none'; };
  scratchState.inited = true;
}

if(giftBtnEl){ giftBtnEl.addEventListener('click',(e)=>{ e.stopPropagation(); if(!scratchState.inited) initScratch(); giftModal.style.display='flex'; giftModal.setAttribute('aria-hidden','false'); }); }
if(giftCloseModal){ giftCloseModal.addEventListener('click', ()=>{ giftModal.style.display='none'; giftModal.setAttribute('aria-hidden','true'); }); }
if(giftModal){ giftModal.addEventListener('click',(e)=>{ if(e.target===giftModal){ giftModal.style.display='none'; giftModal.setAttribute('aria-hidden','true'); } }); }

// lotto removed
  window.addEventListener('click',(e)=>{ if(!lottoCard || lottoCard.style.display!=='block') return; if(e.target.closest && e.target.closest('#lottoCard')) return; lottoCard.style.display='none'; });

  // attach simple keyboard close (Esc)
  window.addEventListener('keydown',(e)=>{ if(e.key==='Escape') { if(lottoCard) lottoCard.style.display='none'; } });

  // init three.js and UI handlers
  try{ createPlane(); updateSize(); renderLoop(); }catch(e){ console.warn('three init error',e); }

  const cardEl = document.getElementById('card');
  const openCardBtn = document.getElementById('openCardBtn');
  function closeCard(){ if(!cardEl) return; cardEl.classList.add('closing'); setTimeout(()=>{ cardEl.style.display='none'; cardOpen=false; },500); }
  if(openCardBtn) openCardBtn.addEventListener('click', (e)=>{ if(cardOpen===false) return; spawnHearts(70); setTimeout(()=>{ closeCard(); },3000); });

  window.addEventListener('click', (e)=>{ if(cardOpen) return; const target=e.target; if(target.closest && target.closest('.clean-btn')) return; if(!isTouchScreen){ pointer.x = e.pageX/innerWidth; pointer.y = e.pageY/innerHeight; pointer.clicked = true; } });
  window.addEventListener('touchstart', (e)=>{ if(cardOpen) return; isTouchScreen=true; const t=e.targetTouches[0]; pointer.x = t.pageX/innerWidth; pointer.y = t.pageY/innerHeight; pointer.clicked=true; },{passive:true});

  cleanBtn.addEventListener('click', cleanCanvas);
  window.addEventListener('resize', ()=>{ updateSize(); });

  // hide name after 3s
  setTimeout(()=>{ const nm=document.getElementById('animatedName'); if(nm) nm.classList.add('hideText'); },3000);
});
</script>
</body>
</html>
